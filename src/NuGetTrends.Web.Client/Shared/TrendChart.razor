@inject ILogger<TrendChart> Logger

<ApexChart @ref="_chart"
           TItem="DownloadDataPoint"
           Options="_options"
           Height="380"
           XAxisType="XAxisType.Datetime">

    @foreach (var package in Datasets)
    {
        <ApexPointSeries @key="package.Id" TItem="DownloadDataPoint"
                         Items="GetDataPoints(package)"
                         Name="@package.Id"
                         SeriesType="SeriesType.Line"
                         XValue="e => e.Timestamp"
                         YValue="e => e.Count"
                         Color="@package.Color" />
    }
</ApexChart>

@code {
    [Parameter, EditorRequired]
    public List<PackageDownloadHistory> Datasets { get; set; } = [];

    [Parameter]
    public int SearchPeriod { get; set; }

    [Parameter]
    public bool IsDark { get; set; }

    private ApexChart<DownloadDataPoint>? _chart;
    private ApexChartOptions<DownloadDataPoint> _options = null!;
    private bool _previousIsDark;
    private int _previousSearchPeriod;
    private int _previousDatasetCount;

    protected override void OnInitialized()
    {
        _previousIsDark = IsDark;
        _previousSearchPeriod = SearchPeriod;
        _previousDatasetCount = Datasets.Count;
        _options = BuildOptions();
    }

    protected override async Task OnParametersSetAsync()
    {
        if (_chart is null)
        {
            return;
        }

        var themeChanged = _previousIsDark != IsDark;
        var periodChanged = _previousSearchPeriod != SearchPeriod;
        var datasetsChanged = _previousDatasetCount != Datasets.Count;

        _previousIsDark = IsDark;
        _previousSearchPeriod = SearchPeriod;
        _previousDatasetCount = Datasets.Count;

        try
        {
            if (themeChanged || periodChanged)
            {
                _options = BuildOptions();
                await _chart.UpdateOptionsAsync(true, true, false);
            }

            if (datasetsChanged || periodChanged)
            {
                await _chart.RenderAsync();
            }
        }
        catch (Exception ex)
        {
            Logger.LogWarning(ex, "Failed to update chart");
        }
    }

    private static List<DownloadDataPoint> GetDataPoints(PackageDownloadHistory package)
    {
        return package.Downloads
            .Where(d => d.Count.HasValue)
            .Select(d => new DownloadDataPoint { Timestamp = d.Week, Count = (decimal)d.Count!.Value })
            .ToList();
    }

    private ApexChartOptions<DownloadDataPoint> BuildOptions()
    {
        var gridColor = IsDark ? "rgba(255, 255, 255, 0.1)" : "rgba(0, 0, 0, 0.1)";
        var textColor = IsDark ? "#a0a0a0" : "#666666";

        // Adapt marker size to the data density
        var showMarkers = SearchPeriod <= 12;

        // Set x-axis min so the axis spans the full requested period,
        // but extend further if the data starts before the period boundary.
        var periodStart = DateTime.UtcNow.AddMonths(-SearchPeriod);
        var earliestWeek = Datasets
            .SelectMany(p => p.Downloads)
            .Where(d => d.Count.HasValue)
            .Select(d => d.Week)
            .DefaultIfEmpty(periodStart)
            .Min();
        var xMinDate = earliestWeek < periodStart ? earliestWeek : periodStart;
        var xMin = new DateTimeOffset(xMinDate).ToUnixTimeMilliseconds();

        return new ApexChartOptions<DownloadDataPoint>
        {
            Chart = new Chart
            {
                Toolbar = new Toolbar { Show = false },
                Zoom = new Zoom { Enabled = false },
                Animations = new Animations
                {
                    Enabled = true,
                    Easing = Easing.Easeinout,
                    Speed = 400,
                    AnimateGradually = new AnimateGradually { Enabled = false },
                },
                Background = "transparent",
                FontFamily = "inherit",
                ForeColor = textColor,
            },
            Legend = new Legend { Show = false },
            Markers = new Markers
            {
                Size = showMarkers ? 4 : 0,
                Hover = new MarkersHover { SizeOffset = showMarkers ? 3 : 5 },
                StrokeWidth = new Size(showMarkers ? 1 : 0),
                StrokeColors = new Color("#fff"),
                Shape = MarkerShape.Circle,
            },
            Stroke = new Stroke
            {
                Curve = Curve.Smooth,
                Width = 2,
            },
            Grid = new Grid
            {
                BorderColor = gridColor,
            },
            Xaxis = new XAxis
            {
                Type = XAxisType.Datetime,
                Min = xMin,
                Labels = new XAxisLabels
                {
                    DatetimeFormatter = new DatetimeFormatter
                    {
                        Day = "dd MMM",
                        Month = "MMM yyyy",
                        Year = "yyyy",
                    },
                    Style = new AxisLabelStyle
                    {
                        Colors = new Color(textColor),
                        FontSize = "13px",
                    },
                },
                AxisBorder = new AxisBorder { Color = gridColor },
                AxisTicks = new AxisTicks { Color = gridColor },
            },
            Yaxis = new List<YAxis>
            {
                new()
                {
                    Labels = new YAxisLabels
                    {
                        Style = new AxisLabelStyle
                        {
                            Colors = new Color(textColor),
                            FontSize = "13px",
                        },
                        Formatter = @"function(val) {
                            if (val === null || val === undefined || isNaN(val)) return '';
                            if (val >= 1e9) return (val / 1e9).toFixed(1).replace(/\.0$/, '') + 'B';
                            if (val >= 1e6) return (val / 1e6).toFixed(1).replace(/\.0$/, '') + 'M';
                            if (val >= 1e3) return (val / 1e3).toFixed(1).replace(/\.0$/, '') + 'K';
                            return val.toLocaleString();
                        }",
                    },
                },
            },
            Tooltip = new Tooltip
            {
                Theme = IsDark ? Mode.Dark : Mode.Light,
                Shared = true,
                Intersect = false,
                X = new TooltipX
                {
                    Format = "dd MMM yyyy",
                },
                Y = new TooltipY
                {
                    Formatter = @"function(value) { return value.toLocaleString(); }",
                },
            },
        };
    }
}
